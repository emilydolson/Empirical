For AvidaGP, we need to do a lot of fine-tuning.

Things to try:
* Is 16 the right number of registers / scopes / etc.
* Regs -as- stacks?
* Skewed mutations so that lower args are more likely than higher ones?
* All data can be vectors that can be rotated or merged?
  (better for lots of data, acted on in parallel and processed on a GPU...)
* Explore var scoping in functions?  Back up ALL regs but return value?
* Do jumps add anything?
  Do we need both While and Countdown?
  Are functions actually used?
  Do we need Test instructions? (or can they be duplicated with math?)
* Fewer args?  Only 2-input math has 3 args.  Change to +=, *=, etc, then cap at 2 args?
* Change stacks to maps.
  Push -> Save MAP KEY REG_VAL
  Pop -> Load MAP KEY REG
  Input will refresh a full MAP with inputs
  Output triggers results from a full map.
  + Shift MAP ?
  + Flip MAP ?
  + Copy MAP ?
  + Add/Sub/Mult/Div Maps ??


And for shifting to regular Avida:
* Can we get the instruction set to 16 so that everything is the same base?
* Can we shift to old-style Avida formatting (16 new nops; instruction defaults are nop-modified)